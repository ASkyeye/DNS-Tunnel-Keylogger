#include <iostream>
#include <windows.h>

HHOOK _k_hook;
HKL keyboardLayout;

/**
 * nCode: should be 0, indicating that wParam and lParam have information about
 *     the keystroke
 * wParam: key code generated by keystroke message
 * lParam: information about the keystroke
 */
LRESULT __stdcall processKey(int nCode, WPARAM wParam, LPARAM lParam) {
	if (nCode >= 0) {  // do not process key if < 0, as specified by documentation
		PKBDLLHOOKSTRUCT key = (PKBDLLHOOKSTRUCT)lParam;  
		if (wParam == WM_KEYDOWN && nCode == HC_ACTION) {
			GetKeyState(VK_SHIFT);
			BYTE keyboardState[256];
			GetKeyboardState(keyboardState);
			
			unsigned short translatedChar[2];
			
			if (ToAsciiEx(key->vkCode, key->scanCode, keyboardState, translatedChar, key->flags, keyboardLayout) == 1) {  // if only one key in buffer
				std::cout << key->vkCode << "->" << (char)translatedChar[0] << std::endl;
			}
		}
	}
	
	return CallNextHookEx(NULL, nCode, wParam, lParam);
}

int main(int argc, char* argv[]) {
	// global keyboard hook that calls processKey
	_k_hook = SetWindowsHookEx(WH_KEYBOARD_LL, processKey, NULL, 0);
	keyboardLayout = GetKeyboardLayout(0);
	MSG msg;
	
	// message loop
	while (GetMessage(&msg, NULL, 0, 0) != 0) {
		// pass the key along, allowing to to be used by other processes
		TranslateMessage(&msg);
		DispatchMessageW(&msg);
	}
	
	// end of program, if hook successful, unhook
	if (_k_hook) {
		UnhookWindowsHookEx(_k_hook);
	}
	
	return TRUE;
}